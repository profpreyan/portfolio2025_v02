<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Preyan Mehta 2025</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script src="https://unpkg.com/@rive-app/webgl2"></script>
  <script>
    const canvas = document.getElementById("canvas");
    let r; // Rive instance
    let viewModelInstance;

    /* ---------- Helpers ---------- */
    function addMQListener(mq, cb) {
      if (mq.addEventListener) mq.addEventListener("change", cb);
      else if (mq.addListener) mq.addListener(cb);
    }
    function updateBrowserDimensions() {
      const browserWidth  = window.innerWidth  || document.documentElement.clientWidth  || document.body.clientWidth;
      const browserHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      if (viewModelInstance) {
        try { viewModelInstance.number("artboardWidth").value  = browserWidth; } catch {}
        try { viewModelInstance.number("artboardHeight").value = browserHeight; } catch {}
      }
      return { browserWidth, browserHeight };
    }
    const dims = updateBrowserDimensions();

    /* ---------- Cursor control (pointer only) ---------- */
    function setPointer(active) {
      canvas.style.cursor = active ? "pointer" : "default";
    }
    const entryExitCursorEvents = new Map([
      ["lkdent", true], ["lkdext", false],
      ["rsment", true], ["rsmext", false],
      ["cseent", true], ["cseext", false],
      ["styent", true], ["styext", false],
    ]);
    const hoverNames = new Set(["lkdhov", "rsmhov", "styhov", "csehov"]);
    const pointerSignals = ["hover","pointer","hand","enter","over","focus"];
    const defaultSignals = ["leave","exit","out","default","reset","idle"];

    function normalize(s){ return typeof s === "string" ? s.trim().toLowerCase() : ""; }
    function includesAny(str, list){ str = normalize(str); return list.some(t => str.includes(t)); }

    function resolveCursorIntent(evData){
      const name = normalize(evData.name);
      const direct = entryExitCursorEvents.get(name);
      if (typeof direct === "boolean") { setPointer(direct); return; }

      if (hoverNames.has(name)) {
        const p = evData.properties || {};
        if (typeof p.hover === "boolean" || typeof p.isHover === "boolean") {
          setPointer(Boolean(p.hover ?? p.isHover)); return;
        }
        const text =
          p.cursor ?? p.Cursor ?? p.intent ?? p.Intent ??
          p.state ?? p.State ?? p.message ?? p.Message ?? "";
        if (includesAny(text, defaultSignals)) { setPointer(false); return; }
        if (includesAny(text, pointerSignals)) { setPointer(true);  return; }
        // Fallback for generic hover event name
        setPointer(true);
        return;
      }

      // Generic property-only signaling
      const p = evData.properties || {};
      if (typeof p.hover === "boolean" || typeof p.isHover === "boolean") {
        setPointer(Boolean(p.hover ?? p.isHover)); return;
      }
      const text =
        p.cursor ?? p.Cursor ?? p.intent ?? p.Intent ??
        p.state ?? p.State ?? p.message ?? p.Message ?? name;
      if (includesAny(text, pointerSignals)) setPointer(true);
      else if (includesAny(text, defaultSignals)) setPointer(false);
    }

    /* ---------- Rive init ---------- */
    r = new rive.Rive({
      src: "/assets/rive/home_v01.riv",
      canvas,
      autoplay: true,
      artboard: "home",
      autoBind: true,
      stateMachines: "mainAnim",
      layout: new rive.Layout({ align: rive.Alignment.Center }),
      onLoad: () => {
        r.resizeDrawingSurfaceToCanvas();
        viewModelInstance = r.viewModelInstance;
        try { viewModelInstance.number("artboardWidth").value  = dims.browserWidth; } catch {}
        try { viewModelInstance.number("artboardHeight").value = dims.browserHeight; } catch {}

        initScrollTrigger();

        const { EventType, RiveEventType } = rive;
        r.on(EventType.RiveEvent, (rev) => {
          const data = rev.data;
          if (!data) return;

          if (data.type === RiveEventType.General) {
            resolveCursorIntent(data);
          } else if (data.type === RiveEventType.OpenUrl && data.url) {
            setPointer(false);
            window.location.href = data.url;
          }
        });

        // Start with default cursor
        setPointer(false);
      },
    });

    /* ---------- Resize ---------- */
    function onResize() {
      if (!r) return;
      r.resizeDrawingSurfaceToCanvas();
      updateBrowserDimensions();
    }
    window.addEventListener("resize", onResize);
    addMQListener(window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`), onResize);

    /* ---------- Scroll booleans (unchanged) ---------- */
    function initScrollTrigger() {
      let isActive = false;
      let timeout;
      window.addEventListener(
        "wheel",
        (e) => {
          const inputs = r.stateMachineInputs("mainAnim");
          if (!inputs) return;

          const downBool = inputs.find(i => i.name === "isScrollingDn" && typeof i.value === "boolean");
          const upBool   = inputs.find(i => i.name === "isScrollingUp" && typeof i.value === "boolean");
          if (!downBool || !upBool) return;

          if (!isActive) {
            isActive = true;
            if (e.deltaY > 0) downBool.value = true;
            else if (e.deltaY < 0) upBool.value = true;

            clearTimeout(timeout);
            timeout = setTimeout(() => {
              downBool.value = false;
              upBool.value = false;
              isActive = false;
            }, 500);
          }
        },
        { passive: true }
      );
    }
  </script>
</body>
</html>
