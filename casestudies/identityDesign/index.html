<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Identity Design</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      transition: background 300ms ease;
    }
    #canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      z-index: 0;
      cursor: default;
    }

    .media-wrap {
      position: fixed;
      top: 12vh;
      right: 3vw;
      bottom: 21vh;
      left: 3vw;
      display: grid;
      place-items: center;
      z-index: 1;
    }
    .stage {
      width: 100%;
      height: 100%;
      background: #000;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .stage img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      object-position: center;
      image-rendering: auto;
      opacity: 0;
      transition: opacity 200ms ease;
      background: #000;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="media-wrap" aria-label="Featured image">
    <div class="stage">
      <img id="galleryImage" alt="project image" />
    </div>
  </div>

  <script src="https://unpkg.com/@rive-app/webgl2"></script>
  <script>
    /* ---------- Slides (index = slideNo - 1) ---------- */
    const images = [
      "/assets/img/pro3/1.gif",
      "/assets/img/pro3/2.gif",
      "/assets/img/pro3/3.png",
      "/assets/img/pro3/4.png",
      "/assets/img/pro3/6.png",
      "/assets/img/pro3/7.png",
      "/assets/img/pro3/8.png",
      "/assets/img/pro3/9.png",
      "/assets/img/pro3/10.gif",
    ];

    const preload = new Map();
    function ensurePreloaded(src) {
      if (preload.has(src)) return preload.get(src);
      const img = new Image();
      img.decoding = "async";
      img.loading = "eager";
      img.src = src;
      preload.set(src, img);
      return img;
    }
    images.forEach(ensurePreloaded);

    /* ---------- Elements ---------- */
    const canvas = document.getElementById("canvas");
    const imgEl  = document.getElementById("galleryImage");

    /* ---------- Utils ---------- */
    function addMQListener(mq, cb) {
      if (mq.addEventListener) mq.addEventListener("change", cb);
      else if (mq.addListener) mq.addListener(cb);
    }
    function updateBrowserDimensions() {
      const w = window.innerWidth  || document.documentElement.clientWidth  || document.body.clientWidth;
      const h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      if (viewModelInstance) {
        try { viewModelInstance.number("artboardWidth").value  = w; } catch {}
        try { viewModelInstance.number("artboardHeight").value = h; } catch {}
      }
      return { w, h };
    }
    let { w: browserWidth, h: browserHeight } = updateBrowserDimensions();

    /* ---------- Cursor: pointer only ---------- */
    function setPointer(active) {
      canvas.style.cursor = active ? "pointer" : "default";
    }

    const entryExitCursorEvents = new Map([
      ["lkdent", true], ["lkdext", false],
      ["rsment", true], ["rsmext", false],
      ["cseent", true], ["cseext", false],
      ["styent", true], ["styext", false],
      ["hmeent", true], ["hmeext", false],
    ]);
    const hoverEventNames = new Set(["lkdhov","rsmhov","styhov","csehov"]);
    const cursorPointerSignals = ["hover","pointer","hand","enter","over","focus"];
    const cursorDefaultSignals = ["leave","exit","out","default","reset","idle"];

    const normalize = (s) => (typeof s === "string" ? s.trim().toLowerCase() : "");
    const includesAny = (str, signals) => signals.some(t => normalize(str).includes(t));

    function handleNamedCursorEvent(evData){
      const name = normalize(evData.name);
      const direct = entryExitCursorEvents.get(name);
      if (typeof direct === "boolean") { setPointer(direct); return true; }

      if (!hoverEventNames.has(name)) return false;
      const p = evData.properties || {};
      const explicit = [p.hover, p.isHover, p.hovering, p.isHovering, p.pointer, p.isPointer]
        .find(v => typeof v === "boolean");
      if (typeof explicit === "boolean") { setPointer(explicit); return true; }

      const text = p.cursor ?? p.Cursor ?? p.intent ?? p.Intent ?? p.state ?? p.State ?? p.message ?? p.Message ?? "";
      if (includesAny(text, cursorDefaultSignals)) { setPointer(false); return true; }
      if (includesAny(text, cursorPointerSignals)) { setPointer(true);  return true; }
      setPointer(true); // fallback for *hov
      return true;
    }

    function resolveCursorIntent(evData){
      if (handleNamedCursorEvent(evData)) return;

      const p = evData.properties || {};
      const boolHover = [p.hover, p.isHover, p.isHovering, p.hovering].find(v => typeof v === "boolean");
      if (typeof boolHover === "boolean") { setPointer(boolHover); return; }

      const candidates = [p.cursor, p.Cursor, p.intent, p.Intent, p.state, p.State, p.message, p.Message, evData.name]
        .filter(v => typeof v === "string");

      if (candidates.some(c => includesAny(c, cursorPointerSignals))) setPointer(true);
      else if (candidates.some(c => includesAny(c, cursorDefaultSignals))) setPointer(false);
    }

    /* ---------- Image binding ---------- */
    let currentIndex = -1;
    async function setImageByIndex(i) {
      i = Math.max(0, Math.min(images.length - 1, i));
      if (i === currentIndex) return;
      currentIndex = i;
      const src = images[i];
      const pre = ensurePreloaded(src);
      imgEl.style.opacity = 0;
      try { if (pre.decode) await pre.decode(); } catch {}
      imgEl.src = src;
      imgEl.alt = `project image ${i + 1} of ${images.length}`;
      requestAnimationFrame(() => { imgEl.style.opacity = 1; });
    }

    /* ---------- Rive + ViewModel ---------- */
    let r, viewModelInstance;
    const { EventType, RiveEventType } = rive;

    function adjustSlide(delta) {
      const slideNo = viewModelInstance?.number("slideNo");
      if (!slideNo) return;
      const current = Number.isFinite(slideNo.value) ? slideNo.value : 1;
      const next = Math.max(1, Math.min(images.length, Math.round(current + delta)));
      if (next !== slideNo.value) slideNo.value = next;
    }

    const SCROLL_DEBOUNCE_MS = 150;
    let lastScrollAt = 0;
    function handleWheel(evt) {
      if (!viewModelInstance) return;
      const direction = evt.deltaY !== 0 ? Math.sign(evt.deltaY) : Math.sign(evt.deltaX);
      if (!direction) return;
      const now = Date.now();
      if (now - lastScrollAt < SCROLL_DEBOUNCE_MS) return;
      if (evt.cancelable) evt.preventDefault();
      adjustSlide(direction);
      lastScrollAt = now;
    }
    window.addEventListener("wheel", handleWheel, { passive: false });

    r = new rive.Rive({
      src: "/assets/rive/pro3_v01.riv",
      canvas,
      autoplay: true,
      artboard: "home",
      autoBind: true,
      stateMachines: "mainAnim",
      layout: new rive.Layout({ align: rive.Alignment.Center }),
      onLoad: () => {
        r.resizeDrawingSurfaceToCanvas();
        viewModelInstance = r.viewModelInstance;

        try { viewModelInstance.number("artboardWidth").value  = browserWidth; } catch {}
        try { viewModelInstance.number("artboardHeight").value = browserHeight; } catch {}

        startSlideSync();
        r.on(EventType.RiveEvent, (ev) => {
          const data = ev.data;
          if (!data) return;

          if (data.type === RiveEventType.General) {
            resolveCursorIntent(data);
          } else if (data.type === RiveEventType.OpenUrl && data.url) {
            setPointer(false);
            window.location.href = data.url;
          }
        });

        setPointer(false);
      },
    });

    /* ---------- Resize ---------- */
    function resize() {
      if (!r) return;
      r.resizeDrawingSurfaceToCanvas();
      ({ w: browserWidth, h: browserHeight } = updateBrowserDimensions());
    }
    window.addEventListener("resize", resize);
    addMQListener(window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`), resize);

    /* ---------- Slide sync loop (reads ViewModel.slideNo) ---------- */
    let lastSlideNo = null;
    function readSlideNo() {
      try {
        const n = viewModelInstance?.number("slideNo")?.value;
        return Number.isFinite(n) ? n : 1;
      } catch { return 1; }
    }
    function startSlideSync() {
      function tick() {
        const raw = readSlideNo();
        const clamped = Math.max(1, Math.min(images.length, Math.round(raw)));
        if (clamped !== lastSlideNo) {
          lastSlideNo = clamped;
          setImageByIndex(clamped - 1);
        }
        requestAnimationFrame(tick);
      }
      const init = Math.max(1, Math.min(images.length, Math.round(readSlideNo())));
      lastSlideNo = null;
      setImageByIndex(init - 1);
      requestAnimationFrame(tick);
    }
  </script>
</body>
</html>
