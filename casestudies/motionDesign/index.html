<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Work â€“ Images over Rive</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      transition: background 300ms ease
    }

    #canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      z-index: 0
    }

    .media-wrap {
      position: fixed;
      top: 12vh;
      right: 3vw;
      bottom: 21vh;
      left: 3vw;
      display: grid;
      place-items: center;
      z-index: 1
    }

    .stage {
      width: 100%;
      height: 100%;
      background: #000;
      border-radius: 12px;
      /* box-shadow: 0 9px 30px rgba(255, 255, 255, .35); */
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden
    }

    .stage img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      object-position: center;
      image-rendering: auto;
      opacity: 0;
      transition: opacity 200ms ease;
      background: #000;
      display: block
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <div class="media-wrap" aria-label="Featured image">
    <div class="stage">
      <img id="galleryImage" alt="project image" />
    </div>
  </div>

  <script src="https://unpkg.com/@rive-app/webgl2"></script>
  <script>
    // ---- Slides (index = slideNo - 1) ----
    const images = [
      "/assets/img/pro1/1.gif",
      "/assets/img/pro1/2.png",
      "/assets/img/pro1/3.png",
      "/assets/img/pro1/4.png",
      "/assets/img/pro1/5.gif",
      "/assets/img/pro1/6.gif",
      "/assets/img/pro1/7.png",
      "/assets/img/pro1/8.png",
      "/assets/img/pro1/9.png",
      "/assets/img/pro1/10.png",
      "/assets/img/pro1/11.gif",
      "/assets/img/pro1/12.gif",
      "/assets/img/pro1/13.gif",
      "/assets/img/pro1/14.gif",
      "/assets/img/pro1/15.gif",
      "/assets/img/pro1/16.gif",
      "/assets/img/pro1/17.gif",
    ];

    // Preload
    const preload = new Map();
    function ensurePreloaded(src) {
      if (preload.has(src)) return preload.get(src);
      const img = new Image(); img.decoding = "async"; img.loading = "eager"; img.src = src;
      preload.set(src, img); return img;
    }
    images.forEach(ensurePreloaded);

    const imgEl = document.getElementById("galleryImage");
    let currentIndex = -1; // force first render

    async function setImageByIndex(i) {
      i = Math.max(0, Math.min(images.length - 1, i));
      if (i === currentIndex) return;
      currentIndex = i;
      const src = images[i];
      const pre = ensurePreloaded(src);
      imgEl.style.opacity = 0;
      try { if (pre.decode) await pre.decode(); } catch (_) { }
      imgEl.src = src;
      imgEl.alt = `project image ${i + 1} of ${images.length}`;
      requestAnimationFrame(() => imgEl.style.opacity = 1);
      try { console.log("[Gallery] showing", i, src); } catch { }
    }

    // ---- Rive + ViewModel binding ----
    const canvas = document.getElementById("canvas");
    let r, viewModelInstance;

    function addMQListener(mq, cb) { if (mq.addEventListener) mq.addEventListener("change", cb); else if (mq.addListener) mq.addListener(cb); }

    function updateBrowserDimensions() {
      const w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      const h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      if (viewModelInstance) {
        try { viewModelInstance.number("artboardWidth").value = w; } catch { }
        try { viewModelInstance.number("artboardHeight").value = h; } catch { }
      }
      return { w, h };
    }
    let { w: browserWidth, h: browserHeight } = updateBrowserDimensions();

    r = new rive.Rive({
      src: "/assets/rive/pro1_v01.riv",
      canvas,
      autoplay: true,
      artboard: "home",
      autoBind: true,
      stateMachines: "mainAnim",
      layout: new rive.Layout({ align: rive.Alignment.Center }),
      onLoad: () => {
        r.resizeDrawingSurfaceToCanvas();
        viewModelInstance = r.viewModelInstance;

        // Bind responsive numbers
        try { viewModelInstance.number("artboardWidth").value = browserWidth; } catch { }
        try { viewModelInstance.number("artboardHeight").value = browserHeight; } catch { }

        // Initial sync from slideNo
        startSlideSync();
        try {
          console.log("[Rive] Loaded. Using ViewModel numbers:", {
            has_slideNo: !!viewModelInstance.number("slideNo"),
            has_artboardWidth: !!viewModelInstance.number("artboardWidth"),
            has_artboardHeight: !!viewModelInstance.number("artboardHeight"),
          });
        } catch { }
      },
    });

    // Keep canvas crisp & update model size
    const resize = () => {
      if (!r) return;
      r.resizeDrawingSurfaceToCanvas();
      ({ w: browserWidth, h: browserHeight } = updateBrowserDimensions());
    };
    window.addEventListener("resize", resize);
    addMQListener(window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`), resize);

    // ---- Slide sync loop: reads home.slideNo ----
    let lastSlideNo = null;
    function readSlideNo() {
      try {
        const n = viewModelInstance?.number("slideNo")?.value;
        return Number.isFinite(n) ? n : 1;
      } catch { return 1; }
    }
    function startSlideSync() {
      function tick() {
        const raw = readSlideNo();
        // clamp to 1..images.length and round
        const clamped = Math.max(1, Math.min(images.length, Math.round(raw)));
        if (clamped !== lastSlideNo) {
          lastSlideNo = clamped;
          setImageByIndex(clamped - 1);
        }
        requestAnimationFrame(tick);
      }
      // show something immediately
      const init = Math.max(1, Math.min(images.length, Math.round(readSlideNo())));
      lastSlideNo = null; // force update
      setImageByIndex(init - 1);
      requestAnimationFrame(tick);
    }
  </script>
</body>

</html>